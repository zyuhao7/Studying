# 第一章 - 事务的基本概念
>   
* 事务的特性。
* 事务的类型。
* 本地事务。
* MySQL事务基础。
>   

```c++
// 事务的特性
// 事务的四大特性: 原子性、 一致性、 隔离性、 持久性.
/*
 事务的原⼦性指的是构成事务的所有操作要么全部执⾏成功,要么全部执⾏失败,不可能出现部分执⾏成功,部分执⾏失败的情况.

 事务的⼀致性指的是在事务执⾏之前和执⾏之后,数据始终处于⼀致的状态.

 事务的隔离性指的是并发执⾏的两个事务之间互不⼲扰.

 事务的持久性指的是事务提交完成后,此事务对数据的更改操作会被持久化到数据库中,并且不会被回滚.

Ps: MySQL通过锁和MVCC机制来保证事务的隔离性.

Ps:数据库的事务在实现时,会将⼀次事务中包含的所有操作全部封装成⼀个不可分割的执⾏单元,这个单元中的所有操作要么全部执⾏成功,要么全部执⾏失败。只要其中任意⼀个操作执⾏失败,整个事务就会执⾏回滚操作.

*/



// 事务的类型
//五大类: 扁平事务、带有保存点的扁平事务、链式事务、嵌套事务和分布式事务.

/*
  扁平事务:
扁平事务是事务操作中最常⻅,也是最简单的事务。在数据库中,扁平事务通常由begin或者start transaction 字段开始,由commit或者rollback字段结束.在这之间的所有操作要么全部执⾏成功,要么全部执⾏失败（回滚）.

 带有保存点的扁平事务:
通俗地讲,内部设置了保存点的扁平事务,就是带有保存点的扁平事务。带有保存点的扁平事务通过在事务内部的某个位置设置保存点（savepoint）,达到将当前事务回滚到此位置的⽬的.

示例:
在MySQL数据库中,通过如下命令设置事务的保存点。

savepoint	[savepoint_name]

例如,设置⼀个名称为save_user_point的保存点,代码如下所示。

savepoint	save_user_point;

通过如下命令将当前事务回滚到定义的保存点位置。

rollback	to	[savepoint_name]

例如,将当前事务回滚到定义的名称为save_user_point的保存点位置,代码如下所示。

rollback	to	save_user_point;

通过如下命令删除保存点。

release	savepoint	[savepoint_name]

例如,删除当前事务中名称为save_user_point的保存点,代码如下所示。

release	savepoint	save_user_point;

 链式事务:
链式事务是在带有保存点的扁平事务的基础上, ⾃动将当前事务的上下⽂隐式地传递给下⼀个事务.也就是说, ⼀个事务的提交操作和下⼀个事务的开始操作具备原⼦性,上⼀个事务的处理结果对下⼀个事务是可⻅的,事务与事务之间就像链条⼀样传递下去.

Ps: 链式事务在提交的时候,会释放要提交的事务中的所有锁和保存点.

  嵌套事务:
嵌套事务就是有多个事务处于嵌套状态,共同完成⼀项任务的处理,整个任务具备原⼦性。嵌套事务最外层有⼀个顶层事务,这个顶层事务控制着所有的内部⼦事务,内部⼦事务提交完成后,整体事务并不会提交,只有最外层的顶层事务提交完成后,整体事务才算提交完成.

 分布式事务:
 分布式事务指的是事务的参与者、事务所在的服务器、涉及的资源服务器以及事务管理器等分别位于不同分布式系统的不同服务或数据库节点上。简单来说,分布式事务就是⼀个在不同环境（⽐如不同的数据库、不同的服务器）下运⾏的整体事务。这个整体事务包含⼀个或者多个分⽀事务,并且整体事务中的所有分⽀事务要么全部提交成功,要么全部提交失败。

*/


// 本地事务
// 基于关系型数据库的事务也可以称作本地事务或者传统事务.

// 本地事务具有的典型特征:
/*
1）⼀次事务过程中只能连接⼀个⽀持事务的数据库,这⾥的数据库⼀般指的是关系型数据库.

2）事务的执⾏结果必须满⾜ACID特性. 

3）事务的执⾏过程会⽤到数据库本身的锁机制.
*/

```
![alt text](Pic/image1.png)

```C++
/*
从图1-2中可以看出：

1）客户端开始事务操作之前,需要开启⼀个连接会话;

2）开始会话后,客户端发起开启事务的指令;

3）事务开启后, 客户端发送各种SQL语句处理数据;

4）正常情况下,客户端会发起提交事务的指令, 如果发⽣异常情况,客户端会发起回滚事务的指令;

5）上述流程完成后,关闭会话.
*/



// 本地事务的优缺点
/*
    本地事务的优点总结如下:

1）⽀持严格的ACID特性,这也是本地事务得以实现的基础.

2）事务可靠,⼀般不会出现异常情况.

3）本地事务的执⾏效率⽐较⾼.

4）事务的状态可以只在数据库中进⾏维护,上层的应⽤不必理会事务的具体状态.

5）应⽤的编程模型⽐较简单,不会涉及复杂的⽹络通信.


    本地事务的缺点总结如下:

1）不具备分布式事务的处理能⼒.

2）⼀次事务过程中只能连接⼀个⽀持事务的数据库, 即不能⽤于多个事务性数据库.
*/
```

```c++
// MySQL事务基础
// 在互联⽹领域,MySQL数据库是使⽤最多的关系型数据库之⼀,也是⼀种典型的⽀持事务的关系型数据库.

/* 
  并发事务带来的问题:
  1. 更新丢失 (脏写)
  2. 脏读
  3. 不可重复读
  4. 幻读

  1 更新丢失 (脏写):
  对于同⼀⾏数据,⼀个事务对该⾏数据的更新操作覆盖了其
  他事务对该⾏数据的更新操作.

  本质上是写操作的冲突,解决方法是让每个事务串行执行.

  2 脏读: 
  就是⼀个事务读取了另⼀个事务未提交的数据.

  脏读本质上是读写操作的冲突,解决办法是先写后读,也就是写完之后再读.

  3 不可重复读:
  同⼀个事务,使⽤相同的查询语句,在不同时刻读取到的结果不⼀致.

  不可重复读本质上也是读写操作的冲突,解决办法是先读后写,也就是读完之后再写.

  4 幻读:
  ⼀个事务两次读取⼀个范围的数据记录,两次读取到的结果不同.

  幻读本质上是读写操作的冲突,解决办法是先读后写,也就是读完之后再写.

*/
```

```c++
// MySQL事务隔离级别
  1. 读未提交
  2. 读已提交
  3. 可重复读
  4. 串行化

// 事务隔离级别脏读不可重复读幻读
/*
        读未提交    可能可能可能
        读已提交  不可能可能可能
        可重复读不可能不可能可能
        串⾏化不可能不可能不可能
*/

/*
  MySQL事务隔离级别最佳实践
  在MySQL中创建⼀个test数据库,在test数据库中创建⼀个account数据表作为测试使⽤的账户数据表,如下所示.

mysql>	create	database	test;
Query	OK,	1	row	affected	(0.02	sec)
mysql>	use	test;
Database	changed
mysql>
mysql>	create	table	account(
				->	id	int	not	null	auto_increment,
				->	name	varchar(30)	not	null	default	'',
				->	balance	int	not	null	default	0,
				->	primary	key(id)
				->	)	engine=InnoDB	default	charset=utf8mb4;
Query	OK,	0	rows	affected	(0.02	sec)

创建完数据库和数据表之后,向account数据表中插⼊⼏条测试数据,如下所示.

mysql>	insert	into
				->	test.account(name,	balance)
				->	values
				->	('张三',	300),
				->	('李四',	350),
				->	('王五',	500);
Query	OK,	3	rows	affected	(0.03	sec)
Records:	3		Duplicates:	0		Warnings:	0

  1. 读未提交
  第⼀步：打开服务器终端A,登录MySQL,将当前终端的事务隔离级别设置为read uncommitted,也就是读未提交,如下所示.

  mysql>	set	session	transaction	isolation	level	read	uncommitted;

  在终端A开启事务并查询account数据表中的数据.

  mysql> start transaction;

  mysql> select * from account;
  
  第⼆步：在终端A的事务提交之前,打开服务器的另⼀个终端B,连接MySQL,将当前事务模式设置为read uncommitted并更新account表的数据,将张三的账户余额加100元.

  mysql>	set	session	transaction	isolation	level	read	uncommitted;

  Query	OK,	0	rows	affected	(0.00	sec)

  mysql>	start	transaction;

  Query	OK,	0	rows	affected	(0.00	sec)

  mysql>	update	account	set	balance	=	balance	+	100	where	id	=	1;

  Query	OK,	1	row	affected	(0.00	sec)

  Rows	matched:	1		Changed:	1		Warnings:	0

  在终端B查询account数据表中的数据.

  在终端B中,当前事务未提交时,张三的账户余额变为更新后的值,即400元.

  第三步：在终端A查看account数据表的数据.

  虽然终端B的事务并未提交,但是终端A可以查询到终端B已经更新的数据.

  第四步：如果终端B的事务由于某种原因执⾏了回滚操作,那么终端B中执⾏的所有操作都会被撤销。也就是说,终端A查询到的数据其实就是脏数据.

  在终端B执⾏事务回滚操作,并查询account数据表中的数据.

  mysql> rollback;  

  在终端B执⾏了事务的回滚操作后,张三的账户余额重新变为300元. 

  第五步：在终端A将张三的账户余额减100元,再次查询account数据表的数据,可以发现张三的账户余额变为200元,⽽不是300元.

  mysql> update account set balance = balance - 100 where id = 1;

  mysql> select * from accout;
  +----+--------+---------+
  | id | name   | balance |
  +----+--------+---------+
  |  1 | 张三   |     200 |
  |  2 | 李四   |     350 |
  |  3 | 王五   |     500 |
  +----+--------+---------+

  执⾏第三步时读取到张三的账户余额为400元,然后将张三的账户余额减100元,因为在应⽤程序中并不知道其他会话回滚了事务,所以更新张三的账户余额就变为300元了,这就是脏读的问题。可以采⽤读已提交的事务隔离级别解决这个问题.

*/

/*
    2.  读已提交
    第⼀步：打开⼀个终端A,将当前终端的事务隔离级别设置为read committed,也就是读已提交.

    mysql>	set	session	transaction	isolation	level	read	committed;

    在终端A开启事务并查询account数据表中的数据.
    +----+--------+---------+
    | id | name   | balance |
    +----+--------+---------+
    |  1 | 张三   |     300 |
    |  2 | 李四   |     350 |
    |  3 | 王五   |     500 |
    +----+--------+---------+

    第⼆步：在终端A的事务提交之前,打开终端B,将当前终端的事务隔离级别设置为read committed,开启事务并更新account数据表中的数据,将张三的账户余额增加100元.

    mysql>	set	session	transaction	isolation	level	read	committed;

    mysql>	start	transaction;

    mysql>	update	account	set	balance	=	balance	+	100	where	id	=	1;

    在终端B查询account数据表中的数据:
    +----+--------+---------+
    | id | name   | balance |
    +----+--------+---------+
    |  1 | 张三   |     400 |
    |  2 | 李四   |     350 |
    |  3 | 王五   |     500 |
    +----+--------+---------+

  第三步：在终端B的事务提交之前,在终端A中查询account数据表中的数据.
    +----+--------+---------+
    | id | name   | balance |
    +----+--------+---------+
    |  1 | 张三   |     300 |
    |  2 | 李四   |     350 |
    |  3 | 王五   |     500 |
    +----+--------+---------+
  
  第四步：在终端B提交事务:

    mysql> commit;

  第五步：在终端B提交事务后,在终端A再次查询account数据表中的数据.

    +----+--------+---------+
    | id | name   | balance |
    +----+--------+---------+
    |  1 | 张三   |     400 |
    |  2 | 李四   |     350 |
    |  3 | 王五   |     500 |
    +----+--------+---------+
  
  可以看到,终端A在终端B的事务提交前和提交后读取到的account数据表中的数据不⼀致,产⽣了不可重复读的问题.

  3. 可重复读

    第⼀步：打开终端A,登录MySQL,将当前终端的事务隔离级别设置为repeatable read,也就是可重复读。开启事务并查询account数据表中的数据.

    mysql> set session transaction isolation level repeatable read;

    mysql> start transaction;

    mysql> select * from account;

    +----+--------+---------+
    | id | name   | balance |
    +----+--------+---------+
    |  1 | 张三   |     300 |
    |  2 | 李四   |     350 |
    |  3 | 王五   |     500 |
    +----+--------+---------+

    第⼆步：在终端A的事务提交之前,打开终端B,登录MySQL,将当前终端的事务隔离级别设置为可重复读.开启事务,将张三的账户余额增加100元,随后提交事务.

    mysql>	set	session	transaction	isolation	level	repeatable	read;

    mysql>	start	transaction;

    mysql>	update	account	set	balance	=	balance	+	100	where	id	=	1;

    mysql>	commit;

    接下来,在终端B查询account数据表中的数据.

    +----+--------+---------+
    | id | name   | balance |
    +----+--------+---------+
    |  1 | 张三   |     400 |
    |  2 | 李四   |     350 |
    |  3 | 王五   |     500 |
    +----+--------+---------+

    第三步：在终端A查询account数据表中的数据.

    mysql> select * from account;

    +----+--------+---------+
    | id | name   | balance |
    +----+--------+---------+
    |  1 | 张三   |     300 |
    |  2 | 李四   |     350 |
    |  3 | 王五   |     500 |
    +----+--------+---------+ 

    可以看到,在终端A查询的结果中,张三的账户余额仍为300元,并没有出现不可重复读的问题,说明可重复读的事务隔离级别解决了不可重复读的问题.

    第四步：在终端A为张三的账户增加100元,如下所示.

    mysql>	update	account	set	balance	=	balance	+	100	where	id	=	1;

     mysql> select * from account;
    +----+--------+---------+
    | id | name   | balance |
    +----+--------+---------+
    |  1 | 张三   |     500 |
    |  2 | 李四   |     350 |
    |  3 | 王五   |     500 |
    +----+--------+---------+

    可重复读的隔离级别使⽤了MVCC（Multi-Version Concurrency Control,多版本并发控制）机制,数据库中的查询（select）操作不会更新版本号,是快照读,⽽操作数据表中的数据（insert、update、delete）则会更新版本号,是当前读.

    第五步：在终端B开启事务,插⼊⼀条数据后提交事务.

    mysql>	start	transaction;

    mysql>	insert	into	account(name,	balance)	values('赵六',	100);

    mysql>	commit;

    在终端B查询account数据表中的数据:
    +----+--------+---------+
    | id | name   | balance |
    +----+--------+---------+
    |  1 | 张三   |     400 |
    |  2 | 李四   |     350 |
    |  3 | 王五   |     500 |
    |  4 | 赵六   |     100 |
    +----+--------+---------+
    可以看到,在终端B查询的结果中,已经显示出新插⼊的赵六的账户信息了.

    第六步：在终端A查询account数据表的数据.
    +----+--------+---------+
    | id | name   | balance |
    +----+--------+---------+
    |  1 | 张三   |     500 |
    |  2 | 李四   |     350 |
    |  3 | 王五   |     500 |
    +----+--------+---------+

    可以看到,在终端A查询的数据中,没有赵六的账户信息,说明并明没有出现幻读.

    第七步：在终端A为赵六的账户增加100元.

    mysql>	update	account	set	balance	=	balance	+	100	where	id	=	7;
    +----+--------+---------+
    | id | name   | balance |
    +----+--------+---------+
    |  1 | 张三   |     500 |
    |  2 | 李四   |     350 |
    |  3 | 王五   |     500 |
    |  7 | 赵六   |     200 |
    +----+--------+---------+

    可以看到,在终端A执⾏完数据更新操作后,查询到赵六的账户信息,出现了幻读的问题.
------------------------------------------------6.23-
  4. 串⾏化

    第⼀步：打开终端A,登录MySQL,将当前终端的事务隔离级别设置为serializable,开启事务,然后查询account数据表中id为1的数据
  
    mysql> set session transaction isolation level serializable;

    mysql> start transaction;

    mysql> select * from account where id = 1;
    +----+--------+---------+
    | id | name   | balance |
    +----+--------+---------+
    |  1 | 张三   |     300 |
    +----+--------+---------+

    第⼆步：打开终端B,登录MySQL,将当前终端的事务隔离级别设置为serializable,开启事务,修改account数据表中id为1的数据.

    mysql>	set	session	transaction	isolation	level	serializable;

    mysql>	start	transaction;

    mysql>	update	account	set	balance	=	balance	+	100	where	id	=	1;

    可以看到,在终端B中对account数据表中id为1的数据执⾏更新操作时,会发⽣阻塞,锁超时后会抛出 "ERROR 1205(HY000):Lock wait timeout exceeded:try restarting transaction"错误,避免了幻读.
*/

//   MySQL中锁的分类
/*
    锁是⼀种协调多个进程或多个线程对某⼀资源的访问的机制,MySQL使⽤锁和MVCC机制实现了事务隔离级别.

     性能           操作类型       数据粒度             更细粒度
     /  \             /  \         /  |  \               /    \
悲观锁 乐观锁      读锁  写锁   表锁 行锁 页面锁      间隙锁  临键锁


  1. 悲观锁和乐观锁

    (1) 悲观锁
      顾名思义,悲观锁对于数据库中数据的读写持悲观态度, 即在整个数据处理的过程中, 它会将相应的数据锁定. 在数据库中, 悲观锁的实现需要依赖数据库提供的锁机制,以保证对数据库加锁后,其他应⽤系统⽆法修改数据库中的数据。

      此机制下,数据库读写数据都需要加锁.

    (2) 乐观锁
       顾名思义, 乐观锁对于数据库中数据的读写持乐观态度, 即在整个数据处理的过程中,⼤多数情况下它是通过数据版本记录机制实现的.

       实现乐观锁的⼀种常⽤做法是为数据增加⼀个版本标识,如果是通过数据库实现,往往会在数据表中增加⼀个类似version的版本号字段。在查询数据表中的数据时,会将版本号字段的值⼀起读取出来,当更新数据时,会令版本号字段的值加1。将提交数据的版本与数据表对应记录的版本进⾏对⽐,如果提交的数据版本号⼤于数据表中当前要修改的数据的版本号,则对数据进⾏修改操作。否则,不修改数据表中的数据。

  2. 读锁和写锁

      (1) 读锁
      读锁⼜称为共享锁或S锁（Shared Lock）, 针对同⼀份数据,可以加多个读锁⽽互不影响.

      (2) 写锁
      写锁⼜称为排他锁或X锁（Exclusive Lock）,如果当前写锁未释放,它会阻塞其他的写锁和读锁.

  Ps: 
  需要注意的是,对同⼀份数据,如果加了读锁,则可以继续为其加读锁,且多个读锁之间互不影响,但此时不能为数据增加写锁。⼀旦加了写锁,则不能再增加写锁和读锁。因为读锁具有共享性,⽽写锁具有排他性.

  3. 表锁、⾏锁和⻚⾯锁

    (1) 表锁
    表锁也称为表级锁,就是在整个数据表上对数据进⾏加锁和释放锁。典型特点是开销⽐较⼩,加锁速度快,⼀般不会出现死锁,锁定的粒度⽐较⼤,发⽣锁冲突的概率最⾼,并发度最低.

    在MySQL中, 有两种表级锁模式：⼀种是表共享锁（Table Shard Lock）；另⼀种是表独占写锁（Table Write Lock）.

    例如,为account数据表增加表级读锁, 如下所示。
    
    mysql>	lock	table	account	read;

    为account数据表增加表级写锁, 如下所示。

    mysql>	lock	table	account	write;

    使⽤如下命令可以查看数据表上增加的锁。

    mysql> show	open tables;

    使⽤如下命令可以删除表锁。

    mysql> unlock	tables;

    (2) 行锁
    ⾏锁也称为⾏级锁, 就是在数据⾏上对数据进⾏加锁和释放锁。典型特点是开销⽐较⼤, 加锁速度慢, 可能会出现死锁, 锁定的粒度最⼩, 发⽣锁冲突的概率最⼩, 并发度最⾼.

  Ps:
     1) ⾏锁主要加在索引上, 如果对⾮索引的字段设置条件进⾏更新, ⾏锁可能会变成表锁.

     2）InnoDB的⾏锁是针对索引加锁, 不是针对记录加锁, 并且加锁的索引不能失效, 否则⾏锁可能会变成表锁.

     3）锁定某⼀⾏时, 可以使⽤lock in share mode 命令来指定共享锁, 使⽤for update命令来指定排他锁, 例如下⾯的SQL语句.
      mysql> select	*	from	account	where id = 1 for	update;
 
    （3）⻚⾯锁

      ⻚⾯锁也称为⻚级锁, 就是在⻚⾯级别对数据进⾏加锁和释放锁。对数据的加锁开销介于表锁和⾏锁之间, 可能会出现死锁, 锁定的粒度⼤⼩介于表锁和⾏锁之间, 并发度⼀般
*/
```
![alt text](image.png)

```c++
  /* 
  4. 间隙锁和临键锁

    (1) 间隙锁

      在MySQL中使⽤范围查询时, 如果请求共享锁或排他锁, InnoDB会给符合条件的已有数据的索引项加锁。如果键值在条件范围内, ⽽这个范围内并不存在记录, 则认为此时出现了"间隙（也就是GAP）"。InnoDB存储引擎会对这个"间隙"加锁, ⽽这种加锁机制就是间隙锁（GAP Lock）.

    (2) 临键锁
      临键锁（Next-Key Lock）是⾏锁和间隙锁的组合, 例如上⾯例⼦中的区间(3,20]就可以称为临键锁.
*/
```

```c++
// 死锁的产⽣和预防
// 死锁的必要条件: 互斥条件、 不可剥夺条件、 请求与保持条件、循环等待条件

/*
    (1) 互斥条件
      在⼀段时间内, 计算机中的某个资源只能被⼀个进程占⽤。此时, 如果其他进程请求该资源, 则只能等待.

    (2) 不可剥夺条件
      某个进程获的资源在使用完毕之前, 不能被其他进程强行夺走, 只能由获得资源的进程主动释放.
    
    (3) 请求与保持条件
      进程已经获得了⾄少⼀个资源, ⼜要请求其他资源, 但请求的资源已经被其他进程占有, 此时请求的进程就会被阻塞, 并且不会释放⾃⼰已获得的资源.

    (4) 循环等待条件
      系统中的进程之间相互等待, 同时各⾃占⽤的资源⼜会被下⼀个进程所请求。例如有进程A、进程B和进程C三个进程, 进程A请求的资源被进程B占⽤, 进程B请求的资源被进程C占⽤, 进程C请求的资源被进程A占⽤, 于是形成了循环等待条件,如下:

                     进程 A
                     /    <               
                    <       \  
                进程B ---->  进程C


  Ps:
    只有4个必要条件都满⾜时，才会发⽣死锁.

  处理死锁的方法
  1. 预防死锁.
  2. 避免死锁.
  3. 检测死锁.
  4. 解除死锁.

    1）预防死锁：
      处理死锁最直接的⽅法就是破坏造成死锁的4个必要条件中的⼀个或多个，以防⽌死锁的发⽣.

    2）避免死锁：
      在系统资源的分配过程中,使⽤某种策略或者⽅法防⽌系统进⼊不安全状态,从⽽避免死锁的发⽣.

    3）检测死锁：
      这种⽅法允许系统在运⾏过程中发⽣死锁，但是能够检测死锁的发⽣，并采取适当的措施清除死锁.

    4）解除死锁：
      当检测出死锁后，采⽤适当的策略和⽅法将进程从死锁状态解脱出来.

  Ps:
    通常采⽤ 有序资源分配法 和 银⾏家算法 这两种⽅式来避免死锁
*/
```


```c++
// InnoDB中的MVCC原理(多版本并发控制)
/*
    在MVCC机制中，每个连接到数据库的读操作，在某个瞬间看到的都是数据库中数据的⼀个快照，⽽写操作的事务提交之前，读操作是看不到这些数据的变化的.

    在InnoDB存储引擎中，MVCC机制是通过在每⾏数据表记录后⾯保存两个隐藏的列来实现的，⼀个列⽤来保存⾏的创建版本号，另⼀个列⽤来保存⾏的过期版本号。每当有⼀个新的事务执⾏时，版本号就会⾃动递增。事务开始时刻的版本号作为事务的版本号，⽤于和查询到的每⾏记录的版本号做对⽐.
*/

//本章⼩结
本章主要介绍了事务的基础知识，包括事务的特性、事务的类型、本地事务的概念、MySQL事务基础以及最佳实践等.

```

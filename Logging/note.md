# C++基于多设计模式下的同步&异步⽇志系统
实现功能:
* 多级日志级别
* 同步异步写日志
* 可靠写入日志到 文件、控制台等
* 支持多线程并发写日志

核心技术: 
* 继承和多态的应用
* C++ 11 (auto、多线程、智能指针、 右值引用)
* 双缓冲区
* 生产者消费者模型
* 设计模式(代理、单例、工厂、建造者等)

## 同步写日志
```c++
    业务线程-> [业务程序逻辑] -> [日志逻辑] -> [业务程序逻辑] -> 

    在高并发场景下, 随着日志数量的不断增多, 同步日志系统容易出现系统瓶颈:

     1. 一方面, 大量的日志陷入等量的 write 系统调用, 带来一定系统开销.
     2. 另一方面, 打印日志的进程附带了大量同步的磁盘 IO, 影响程序性能.
```
## 异步写日志
```c++
    异步 IO 是指日志输出语句与业务逻辑语句不在同一个线程中运行, 而是有专门的线程用于进行日志输出操作. 业务线程只需要将日志放入一个内存缓冲区中不用等待即可继续执行后续业务逻辑(日志的生产者), 而日志的拿取操作交给单独的日志线程完成(日志的消费者).

    业务线程 -> [业务逻辑]     -> [日志打印(将日志生产到缓冲区)]

                                            ↓
                                        
                                        (日志缓冲区)

                                            ↓

    日志线程 -> [日志打印逻辑]  ->  [日志打印(消费缓冲区日志写到文件)]

    这样做的好处是即使⽇志没有真的地完成输出也不会影响程序的主业务，可以提⾼程序的性能：
    1. 主线程调用日志打印接口成为非阻塞操作.
    2. 同步的磁盘 IO 从主线程剥离出来交给单独的线程完成.
```

## 不定参函数
## 设计模式
```c++
    六大原则:
    单⼀职责原则、 开闭原则、⾥⽒替换原则、依赖倒置原则、迪⽶特法则、接⼝隔离原则.
    单例、工厂、建造者、代理.
```

## 日志落地类(LogSink) 类设计
```c++
    落地类主要负责落地日志消息到目的地.

    它主要包括以下内容：
    • Formatter⽇志格式化器：主要是负责格式化⽇志消息.
    • mutex互斥锁：保证多线程⽇志落地过程中的线程安全，避免出现交叉输出的情况.

    这个类⽀持可扩展，其成员函数log设置为纯虚函数，当我们需要增加⼀个log输出⽬标， 可以增加⼀个类继承⾃该类并重写log⽅法实现具体的落地⽇志逻辑.
    
    ⽬前实现了三个不同⽅向上的⽇志落地：
    • 标准输出：StdoutSink  
    • 固定⽂件：FileSink  
    • 滚动⽂件：RollSink 
```

## 日志器类设计(Logger) 建造者模式
```c++
    ⽇志器主要是⽤来和前端交互,当我们需要使⽤⽇志系统打印log的时候,只需要创建Logger对象,调⽤该对象debug、info、warn、error、fatal等⽅法输出⾃⼰想打印的⽇志即可，⽀持解析可变参数列表和输出格式,即可以做到像使⽤printf函数⼀样打印⽇志.

    当前⽇志系统⽀持 同步⽇志 & 异步⽇志 两种模式，两个不同的⽇志器唯⼀不同的地⽅在于他们在⽇志的落地⽅式上有所不同：

    同步⽇志器：直接对⽇志消息进⾏输出。
    异步⽇志器：将⽇志消息放⼊缓冲区，由异步线程进⾏输出。


```
### 双缓冲区异步任务处理器（AsyncLooper）设计
```c++
    设计思想：异步处理线程 + 数据池

    双缓冲区是处理器将⼀个缓冲区中的任务全部处理完毕后，然后交换两个缓冲区，重新对新的缓冲区中的任务进⾏处理，虽然同时多线程写⼊也会冲突，但是冲突并不会像每次只处理⼀条的时候频繁（减少了⽣产者与消费者之间的锁冲突），且不涉及到空间的频繁申请释放所带来的消耗.
    
```
### 异步⽇志器(AsyncLogger)设计
```c++
    异步⽇志器类继承⾃⽇志器类，并在同步⽇志器类上拓展了异步消息处理器。当我们需要异步输出⽇志的时候，需要创建异步⽇志器和消息处理器，调⽤异步⽇志器的log、error、info、fatal等函数输出不同级别⽇志.
```

### 单例⽇志器管理类设计（单例模式)
```c++
    ⽇志的输出，我们希望能够在任意位置都可以进⾏，但是当我们创建了⼀个⽇志器之后，就会受到⽇志器所在作⽤域的访问属性限制.

    因此，为了突破访问区域的限制，我们创建⼀个⽇志器管理类，且这个类是⼀个单例类，这样的话，我们就可以在任意位置来通过管理器单例获取到指定的⽇志器来进⾏⽇志输出了.

    基于单例⽇志器管理器的设计思想，我们对于⽇志器建造者类进⾏继承，继承出⼀个全局⽇志器建造者类，实现⼀个⽇志器在创建完毕后，直接将其添加到单例的⽇志器管理器中，以便于能够在任何位置通过⽇志器名称能够获取到指定的⽇志器进⾏⽇志输出.
```

### ⽇志宏&全局接⼝设计（代理模式）
``` c++
    提供全局的⽇志器获取接⼝。

    使⽤代理模式通过全局函数或宏函数来代理 Logger类 的log、debug、info、warn、error、fatal等接⼝，以便于控制源码⽂件名称和⾏号的输出控制，简化⽤⼾操作。当仅需标准输出⽇志的时候可以通过主⽇志器来打印⽇志。且操作时只需要通过宏函数直接进⾏输出即可。
```
# 第一天:认识 git 版本控制

## 学习 git 需要注意的几点
* 先拥有 Git 基础该念，通过指令的方式学习是最快的方式，不要跳过这一段

* 找多一点人跟你一起学 Git 版本控制，最好能直接用在实际的开发工作上

* 团队中最好要有几个先遣部队，可以多学一点 Git 观念,好分享给其他人,或有人有问题时，能随时提供协助

* 了解 Git 属于「分布式版本控制」，每个人都有一份完整的仓库 (Repository)，所以必须经常合并文件

* 使用 Git 的时候，分支与合并是常态，但只要有合并，就会有冲突,要学会如何解决冲突

## 认识 Git 版本控制
```c++
/*
Git 的出现，来自于 Linux 之父 "Linus Torvalds" 开发 Linux kernel 的时候，因为早期的版本控制方法非常没有效率，属集中式控制，当 Linux kernel 这类复杂又庞大的项目在进行版本控制时，出现了许多问题。最早期 Linux kernel 采用 BitKeeper 进行版本控制，但后来 Linus Torvalds 基于 BitKeeper 与 Monotone 的使用经验，设计出更棒的 Git 版控系统。原先 Git 只被设计成一个低阶的版控工具，用来当做其他版控系统 (SCM) 的操作工具，后来才渐渐演变成一套完整的版本控制系统。


有趣的是，Linus Torvalds 改采 Git 进行版本控制初期，由于 Git 太过复杂，许多版控观念跟以往差异太大，也受到世界各地开放源代码社群的反对，但经过几年的努力与发展，操作 Git 的相关工具也越来越成熟，才渐渐平抚反对的压力，从 2013 年的市场调查看来，全世界已有 30% 的开放源代码项目改采 Git 进行版本控制，这是个非常惊人的市占率，意味着 Git 绝对有其惊艳之处，不好好研究一番还不行呢！


讲到 Git 的架构，完全是基于 Linus Torvalds 在维护 Linux kernel 这个大型项目时得到的经验，以及他本身在文件系统优化方面的丰富经验进行设计，也因为这样，Git 包含了以下几个重要的设计:

强力支持非线性开发模式 (分散式开发模式)

    1. Git 拥有快速的分支与合并机制，还包括图形化的工具显示版本变更的历史路径。

    2. Git 非常强调分支与合并，所以版本控制的过程中，你会不断的在执行分支与合并动作。

    3. Git 的分支机制非常轻量，没有负担，每一次的分支只是某个 commit 的参考指标而已。


分散式开发模型

    1. 参与 Git 开发的每个人，都将拥有完整的开发历史记录。

    2. 当开发人员第一次将 Git 版本库复制 (clone) 下来后，完全等同于这份 Git 版本库的「完整备份」。
    
    3. 整个版本库中所有变更过的文件与历史记录，通通都会储存在本机仓库 (local repository)。


相容于现有操作系统

    1. Git 版本库其实就只是一个资料夹而已，资料夹中有许多相关的设定档与各种 blob 物件文件而已。

    2. Git 版本库可以用任何方式发布，所以你用 HTTP, FTP, rsync, SSH 甚至于用 Git protocol 都可以当成存取 Git 版本库的媒介，相容性极高。


有效率的处理大型项目

    1. 由于完整的版本库会复制 (clone) 一份在本机，该版本库包含完整的文件与版本变更记录，所以针对版本控制中的各种文件操作速度，将会比直接从远端存取来的快上百倍之多。

    2. 这也代表着，Git 版本控制不会因为项目越来越大、文件越来越多，而导致速度变慢。


历史记录保护

    1. Git 版控的过程，每次 commit 都会产生一组 hash id 编号，而且每个版本在变化的过程都会参考到这个 hash id，只要 hash id 无法比对的上，Git 就会无法运作，所以当项目越来越大，版本库复制 (clone) 的越来越多份，你几乎无法窜改文件的内容或版本记录。

    2. 请记得: 每个人都有一份完整的版本库，你改了原始的那份，所有人的版本库就无法再合并回原本的版本库了，所以你几乎不可能任意窜改版本记录。


以工具集为主的设计 (Toolkit-based design)

    1. Git 被设计成一个一个的工具软件 (指令列工具)，你可以很轻易的组合不同工具的使用，使用上非常弹性。


弹性的合并策略 (Pluggable merge strategies)

    1. Git 有一个拥有良好设计的「不完整合并 (incomplete merge)」 机制，以及多种可以完成合并的演算法，并在最后告知使用者为何无法自动完成合并，或通知你需要手动进行合并动作。


被动的垃圾回收机制

    1. 在使用 Git 的时候，若想要中断目前的操作或回复上一个操作，都是可以的，你完全可以不必担心可能有其中一个指令下错，或指令执行到一半当机等问题。

    2. Git 的垃圾回收机制，其实就是那些残留在文件系统中的无用文件，这个垃圾回收机制只会在这些无用的物件累积一段时间后自动执行，或你也可以自行下达指令清空它。例如: git gc --prune


定期的封装物件

    1. 我们在 Git 中提到的 "物件" 其实就是代表版本库中的一个文件。而在版本变动的过程中，项目中的代码或其他文件会被更新，每次更新时，只要文件内容不一样，就会建立一个新的 "物件"，这些不同内容的文件全部都会保留下来。

    2. 你应该可以想像，当一个项目越来越大、版本越来越多时，这个物件会越来越多，虽然每个文件都可以各自压缩让文件变小，不过过多的文件还是会文件存取变得越来越没效率。因此 Git 的设计有个机制可以将一群老旧的 "物件" 自动封装进一个封装档 (packfile) 中，以改善文件存取效率。

    3. 那些新增的文件还是会以单一文件的方式存在着，也代表一个 Git 版本库中的 "文件" 就是一个 Git "物件"，但每隔一段时间就会需要重新封装 (repacking)。

    4. 照理说 Git 会自动执行重新封装等动作，但你依然可以自行下达指令执行。例如: git gc
    
    5. 如果你要检查 Git 维护的文件系统是否完整，可以执行以下指令: git fsck

*/
#include <iostream>
using namespace std;

// day-2024-11-4
// 第十三章 - 编码优化

// 要点:
// 编码优化在范围上是局部的, 并且不需要对程序的整体设计有深入地理解。 当加入到一个正在进行的项目开发时,
// 并且对设计不完全理解时, 这会是很好的开始.

// day-2024-11-5
// 第十四章 -  设计优化

//  要点

// 1、 代码细节中可以利用缓存优化代码，在整个程序设计中也能采用这种方法。通常可以通过将先前的计算结果保存起来避免大量的计算。
// 2、对于软件的高效性而言，使用高效的算法和数据结构是必要条件，但并非充分条件。
// 3、有些计算只有在特定执行条件下才需要。这些计算应该被推迟到确实需要它.们的路径上来完成。如果过早地执行计算，那么其结果可能并没有被使用。
// 4、大型软件往往会变得错综复杂，杂乱不堪。混乱软件的一大特点就是执行失效代码:那些曾经用来实现某个目标，但现在已经不需要的代码。
// 定期清理失效和僵死代码可以增强软件性能，同时对于软件也是一种维护。
// 5、在软件性能和灵活性之间存在一种基本的平衡。对于在 80% 时间内执行的 20% 的软件，性能通常损失在灵活性上。

// day-2024-11-6
// 第十五章 - 可扩展性

// 要点

// SMP 是当前主流的多处理器架构。它通过一条总线连接多个对称的处理器和一个内存系统。总线是 SMP架构可扩展性的薄弱环节。
// 让每个处理器都有自己的大缓存可以有效地控制总线的竞争。

// Amdah1 定律给出了一个应用的可扩展性的上限, 顺序化计算限制了扩展性。

// 实现可扩展性的技巧是减少或者消除顺序化的代码。以下是可以达到这个目标的一些步骤 :
// 任务分解 将大的任务分为小任务，使线程并发地执行这些小任务。
// 代码移出 临界区应该只包含关键代码，不直接操作共享资源的代码不要放在临界区内。
// 利用缓存 有时，通过缓存之前访问过的数据，可以消除对临界区的访问。
// 无共享 如果需要少量、数目固定的资源实例，可以不使用公共资源池。您可以把这些资源实例设为线程私有，并最后回收。
// 部分共享 有两个一样的资源池可以减少一半的竞争。
// 锁粒度 不要用同样的锁来保护所有资源，除非这些资源是同时更新的。
// 伪共享 不要在类定义里把两个使用频度都很高的锁放太靠近。您肯定不希望它们共享同一个缓存行并触发缓存一致性风暴。
// 惊群现象 仔细分析您的锁调用的特征。当锁被释放时，是所有的等待线程都被唤醒还是只唤醒一个线程,唤醒所有线程会威胁到应用的可扩展性。
// 系统和类库调用 考察这些调用的实现特征。它们有可能是隐藏了顺序化的代码。
// 读写锁 以读为主的共享数据会从这种锁中获益，使用这种锁，可以消除读者线程之间的竞争。


// 第十六章 - 体系结构相关话题
//     要点
// 要使用的存储器离处理器越远，访问所需的时间就越长。
// 离处理器最近的是寄存器，虽然容量很少，但是速度很快。对寄存器的优化对程序的性能提升而言是极为有益的。
// 虚拟存储器并不是无偿的,不加选择地依赖系统管理的虚拟结构可能会影响性能，而且一般都是降低性能。
// 上下文切换的开销巨大，请避免上下文切换。
// 最后，虽然我们知道内部管理异步 IO 有它的重要作用，我们还是认为正在到来的处理器架构的变化，会使得单个线程方法在这方面的优势减弱。
int main()
{

    return 0;
}
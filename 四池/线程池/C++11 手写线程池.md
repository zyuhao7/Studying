

# C++11 手写线程池



### 项目介绍

线程池应用广泛，不论实在客户端程序还是后台服务程序， 都是提高业务能力的必备模块。 有很多开源的线程池实现，各自接口使用上稍有区别，核心实现原理基本相同。



### 知识储备

- 熟练基于 C++ 11 标准的面向对象编程

 	**组合继承多态、 STL 容器、 智能指针、 函数对象、 绑定器、 可变参数模版编程**

- 熟悉C++11多线程编程

​      **thread、 mutex、 atomic、 condition_variable、 unique_lock**

- **C++ 17 和 C++ 20** 标准的内容

- C++ 17 的 **any** 类型 和 C++ 20 的信号量 **semaphore**
- 熟悉多线程理论

​	**多线程基础知识、 线程互斥、 线程同步、 原子操作、 CAS**



### 并发和并行

-  CPU 单核
-  CPU 多核、  多 CPU

#### 并发

单核上， 多个线程占用不同的 CPU 时间片, 物理上还是串行执行的， 但是由于每个线程占用的 CPU 时间片非常短， 看起来就像是多个线程都在共同执行一样， 这种场景称作 **并发(concurrent)**。

#### 并行

在多核或者多 CPU 上， 多个线程是在真正的同时执行， 这样的场景称作 **并行(parallel)**。



### 多线程的优势

> ​	多线程不一定是越多越好， 具体需要看应用场景

#### IO 密集型

无论是 CPU 单核、 CPU 多核、 多 CPU， 都是比较适合多线程程序的。

#### CPU密集型

- CPU单核



### 线程池

#### 线程的消耗

为了完成任务，创建很多线程可取吗？ 线程是否越多越好？

- 线程的**创建和销毁**都是非常 "重" 的操作
- **线程栈**本身占用大量内存
- 线程的**上下文切换**要占用大量时间
- 大量线程同时唤醒会使系统经常出现**锯齿状负载**或瞬间负载量很大导致**宕机**



#### 线程池的优势

操作系统上创建线程和销毁线程都是很 "重"的操作， 耗时耗性能都比较多， 那么在服务执行的过程中， 如果业务量比较大， 实时的去创建线程、执行业务、业务完成后销毁线程，那么会导致系统的实时性能降低， 业务的处理能力也会降低。

线程池的优势就是在服务进程启动之初， 就事先创建好线程池里的线程， 当业务流量到来时需要分配线程，直接从线程池中获取一个空闲线程执行 task 任务即可， task 执行完成后， 也不用释放线程， 而是把线程归还到线程池中继续为后续的 task 提供服务。



#### fixed 模式线程池

线程池里的线程个数是固定不变的， 一般是 ThreadPool 创建时根据当前及其的 CPU 核心数量进行指定。

#### cached 模式线程池

线程池里面的线程个数是可动态增长的， 根据任务的数量动态的增加线程的数量， 但是会设置一个线程数量的阈值( 线程过多适得其反 )， 任务处理完成， 如果动态增长的线程空闲了 60s 还没有处理其他任务， 那么关闭线程， 保持池中最初数量的线程即可。



### 线程同步(具体图示见 draw.io)

#### 线程互斥

- 互斥锁 mutex
- atomic 原子类型

#### 线程通信

- 信号量 semaphore
- 条件变量 condition_variable

